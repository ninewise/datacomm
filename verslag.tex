\documentclass[]{article}
\usepackage[a4paper]{geometry}
\usepackage[dutch]{babel}

% Floating figuren.
\usepackage{graphicx}

% Commented, want we gebruiken dit eigenlijk niet?
%\usepackage{titling}

% Om code en dergelijke te plaatsen.
\usepackage{listings}

% Wiskundige formules in LaTeX <3
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}

% MATRICES! :D
\usepackage{amsmath}
\setcounter{MaxMatrixCols}{25} 

% Ik vind het nu eenmaal mooier zo.
\setlength{\parindent}{0pt}
\setlength{\parskip}{14pt}

\title{Project Datacommunicatie}
\author{Enver Bral \\
        Fr\'ed\'erique De Baerdemaeker \\
        Ruben Taelman \\
        Felix Van der Jeugt}
\date{Academiejaar 2012 - 2013}

\begin{document}
\maketitle

\begin{section}*{Broncodering}

    \begin{subsection}*{Vraag 1}

        We verkrijgen volgende output bij het uitvoeren van
        \texttt{FrequencyCounter.m}:

        \begin{lstlisting}
            0.5443    0.0024    0.0031    0.0040
            0.0019    0.0045    0.0001    0.0026
            0.0020    0.0001    0.0044    0.0029
            0.0045    0.0025    0.0018    0.4189
        \end{lstlisting}

        Dit zijn de relatieve frequenties voor elk macroblok. De
        macroblokken zijn hier als volgt genummerd: We zetten de rijen
        van het macroblok na elkaar, en lezen als een binair getal.  Zo
        wordt het macroblock \texttt{[1 0;0 1]} omgezet naar
        \texttt{1 0 0 1} en krijgt het nummer $9$.

        Met deze frequenties kunnen we de huffman-boom opstellen. Deze
        vindt u in Figuur~\ref{fig:manual_huffman}. Door aan de
        vertakking met het kleinste deelgewicht een nul toe te kennen,
        en een \'e\'en anders, bekomen we de codering in
        Tabel~\ref{tab:manual_huffman}.

        \begin{figure}
            \centering
            \includegraphics[width=\textwidth]{manual_huffman.png}
            \caption{Huffmanboom, opgesteld bij de frequenties uit
            \label{fig:manual_huffman}
            vraag 1.}
        \end{figure}

        \begin{table}
            \centering
            \begin{tabular}{lr@{.}lr}
                \textbf{Macrosymbool} & \multicolumn{2}{l}{\textbf{Rel. freq.}} &
                \textbf{Codewoord} \\
                \hline
                \texttt{0000} & 54 & 43 \% & \texttt{1} \\
                \texttt{0001} &  0 & 24 \% & \texttt{000101} \\
                \texttt{0010} &  0 & 31 \% & \texttt{001111} \\
                \texttt{0011} &  0 & 40 \% & \texttt{00001} \\
                \texttt{0100} &  0 & 19 \% & \texttt{000000} \\
                \texttt{0101} &  0 & 45 \% & \texttt{00100} \\
                \texttt{0110} &  0 & 01 \% & \texttt{00000100} \\
                \texttt{0111} &  0 & 26 \% & \texttt{001101} \\
                \texttt{1000} &  0 & 20 \% & \texttt{000100} \\
                \texttt{1001} &  0 & 01 \% & \texttt{00000101} \\
                \texttt{1010} &  0 & 44 \% & \texttt{00011} \\
                \texttt{1011} &  0 & 29 \% & \texttt{001110} \\
                \texttt{1100} &  0 & 45 \% & \texttt{00101} \\
                \texttt{1101} &  0 & 25 \% & \texttt{001100} \\
                \texttt{1110} &  0 & 18 \% & \texttt{0000011} \\
                \texttt{1111} & 41 & 89 \% & \texttt{01} \\
            \end{tabular}
            \caption{De Huffmancode bij vraag 1.}
            \label{tab:manual_huffman}
        \end{table}

        Nu kunnen we het gemiddeld aantal codebits per bronsymbool
        eenvoudig berekenen:

        \begin{eqnarray*}
            \mathbb{E}(n)
            &=& \frac{1}{4} \sum^{16}_{i=1}{p_i c_i} \\
            &=& \frac{1}{4*100}(1*54.43 + 6*0.24 + 6*0.31 + 5*0.40
                + 6*0.19 + 5*0.45 + 8*0.01 \\ && + 6*0.26 + 6*0.20
                + 8*0.01 + 5*0.44 + 6*0.29 + 5*0.45 + 6*0.25 \\ &&
                + 7*0.18 + 2*41.89) \\
            &=& \frac{158.77}{400} \\
            &=& 0.396925
        \end{eqnarray*}

        De afbeelding kan dus tot amper 40 procent van zijn
        oorspronkelijke grootte gereduceerd worden met behulp van
        Huffman codering.

    \end{subsection}

    \begin{subsection}*{Vraag 3}

        We verkrijgen volgende grafiek bij het uitvoeren van
        \texttt{vraag1\_3.m}:

        \includegraphics{vraag1_3.png}

        Hierop kunnen we de entropie zien van de macrosymbolen van
        grootte K. De referentielijn is hier een rechte, dit is logisch
        aangezien de entropie maximaal is wanneer alle symbolen met
        gelijke kans voorkomen.
        Vanaf K=8 komen er symbolen voor die met frequentie 0
        voorkomen, dus hier is de log2 -oneindig, dus de entropie wordt
        hier ook oneindig groot.

    \end{subsection}

    \begin{subsection}*{Vraag 4}

        We verkrijgen volgende grafiek bij het uitvoeren van
        \texttt{vraag1\_4.main()}:

        \begin{figure}[h]
            \includegraphics[scale=0.75]{vraag1_4.png}
            \caption{Gemiddeld aantal codebits per bronsymbool}
            \label{fig:codebits}
        \end{figure}

        Hierop kunnen we het gemiddelde aantal codebits per bronsymbool
        (gebruikmakend van huffmancodering) voor macrosymbolen met
        grootte K=1..10 en de bijhorende onder/bovengrens zien. \\

        We vinden dat het bestand het best gecomprimeerd is voor \textbf{K=9} met \textbf{0.2982} codebits per bronsymbool. Dit is eveneens de compressiefactor.
		
    \end{subsection}

    \begin{subsection}*{Vraag 5}

        In Figuur~\ref{fig:codebits} zien we dat $\mathbb{E}[n]$ zeer
        dicht bij de ondergrens ligt. Enkel voor macroblokken van
        grootte \'e\'en is dit niet het geval, maar aangezien we geen
        codewoorden van korter dan \'e\'en bit kunnen toekennen, is dit
        slechts te verwachten. Dit kleine verschil wijst erop dat
        Huffmancodering een zeer goede broncodering is.

        % TODO: Optimaal? Voorwaarden?

    \end{subsection}
    
    \begin{subsection}*{Vraag 6}
    	
    	Vertrekkende van de \emph{niet-canonische} Huffman codes in 
    	tabel~\ref{tab:manual_huffman}, vinden we de canonische
    	Huffman codes gegeven in tabel~\ref{tab:canonical_huffman}
    	
    	\begin{table}
            \centering
            \begin{tabular}{c|r}
                \textbf{Macrosymbool} &
                \textbf{Codewoord} \\
                \hline
                \texttt{0000} & \texttt{0} \\
				\texttt{0001} & \texttt{111000} \\
				\texttt{0010} & \texttt{111001} \\
				\texttt{0011} & \texttt{11000} \\
				\texttt{0100} & \texttt{111010} \\
				\texttt{0101} & \texttt{11001} \\
				\texttt{0110} & \texttt{11111110} \\
				\texttt{0111} & \texttt{111011} \\
				\texttt{1000} & \texttt{111100} \\
				\texttt{1001} & \texttt{11111111} \\
				\texttt{1010} & \texttt{11010} \\
				\texttt{1011} & \texttt{111101} \\
				\texttt{1100} & \texttt{11011} \\
				\texttt{1101} & \texttt{111110} \\
				\texttt{1110} & \texttt{1111110} \\
				\texttt{1111} & \texttt{10} \\
            \end{tabular}
            \caption{Canonische Huffmancodes bij vraag 6}
            \label{tab:canonical_huffman}
        \end{table}
    	
    \end{subsection}

    \begin{subsection}*{Vraag 7}

        %(zie vraag 1_7.txt)

   	\end{subsection}

\end{section}

\begin{section}*{Kanaalcodering}
	\begin{subsection}*{Vraag 1}

        Als minimale Hammingafstand voor de gegeven code bekomen we $d=3$. 
        Hiermee kunnen we het foutdetecterend en corrigerend vermogen berekenen als volgt.
        \begin{eqnarray*}
        	& foutdetecterend vermogen = d-1 = 2 \\
        	& foutcorrigerend vermogen = floor((d-1)/2) = 1 \\
        \end{eqnarray*}        
        
        De checkveelterm kunnen we bepalen aan de hand van volgende vergelijking:
        \begin{eqnarray*}
        	x^{15} + 1 &=& h(x) * g(x)
        \end{eqnarray*}
        We weten al $g(x)$, dus we kunnen met behulp van een Euclidische deling $h(x)$ 
        zoeken. We bekomen:
        \begin{eqnarray*}
        	h(x) &=& x^{11} + x^8 + x^7 + x^5 + x^3 + x^2 + x + 1 \\
        \end{eqnarray*}
        
        Als de matrices bekomen we:
        \begin{eqnarray*}
        G &=&\input{vraag2_1/generatormatrix.tex}\\
        H &=&\input{vraag2_1/checkmatrix.tex}\\
        G_{sys} &=&\input{vraag2_1/syst_generatormatrix.tex}\\
        H_{sys} &=&\input{vraag2_1/syst_checkmatrix.tex}\\
        \end{eqnarray*}

   	\end{subsection}

    \begin{subsection}*{Vraag 2} % Jimmy
    	We bepalen de syndroomtabel met behulp van de coset-leiders. In het totaal zijn er 16 ($2^{n-k}$) syndromen. We kunnen 	
    	snel de coset-leiders bepalen door een nulrij en daaronder een eendheids-matrix te plaatsen. Er is 1 coset-leider met 
    	gewicht 0 en 15 coset-leiders  met gewicht 1. We vermenigvuldigen nu deze coset-leiders met de getransponeerde checkmatrix uit de vorige vraag en bekomen zo de syndromen.\\
    
    	\begin{table}
    		\centering	
    		\begin{tabular}{@{}c|c@{}}
    		Syndroom & Coset-leider \\
    		\hline
    		0000 & 000000000000000 \\
		1100 & 100000000000000\\
		0110 & 010000000000000\\
		0011 & 001000000000000\\
		1101 & 000100000000000\\
		1010 & 000010000000000\\
		0101 & 000001000000000\\
		1110 & 000000100000000\\
		0111 & 000000010000000\\
		1111 & 000000001000000\\
		1011 & 000000000100000\\
		1001 & 000000000010000\\
		1000 & 000000000001000\\
		0100 & 000000000000100\\
		0010 & 000000000000010\\
		0001 & 000000000000001\\
    		\end{tabular}
    		\caption{Syndroomtabel voor de cyclische (15,11) Hammingcode}
    	\end{table}
    
    	
    	De kans op de een decodeerfout na een transmissie over een BSC met bitfoutprobabiliteit $p$ is
    	\begin{eqnarray*}
		Pr[\text{decodeerfout}] &=&1-Pr[\text{geen decodeerfout}] \\   
		&=&1-Pr[\textbf{e} \in \text{syndroomtabel}] \\   
		&=&1- ((1-p)^{15} + 15p(1-p)^{14})
	\end{eqnarray*}
	 
	Met het binomium van Newton kunnen we dit herleiden tot:
	\begin{eqnarray*}
		=&&(\sum_{i=0}^{15}(^{15}_i)p^i(1-p)^{n-i})- (1-p)^{15} - 15p(1-p)^{14} \\ 
		=&& 105p^{2}(1-p)^{13} + 455p^{3}(1-p)^{12} + 1365p^{4}(1-p)^{11}  + 3003p^{5}(1-p)^{10} 
		\\ & +&  5005p^{6}(1-p)^{9} + 6435p^{7}(1-p)^{8} + 6435p^{8}(1-p)^{7} + 5005p^{9}(1-p)^{6} 
		\\ & + & 3003p^{10}(1-p)^{5} + 1365p^{11}(1-p)^{4} + 455p^{12}(1-p)^{3} + 105p^{13}(1-p)^{2} 
		\\ & +&  15p^{14}(1-p) +p^{15}
	\end{eqnarray*}
    
    	Voor $p << 1$ (zeer kleine waarden) kan dit benaderd worden met $105p^2$
    \end{subsection}

    \begin{subsection}*{Vraag 3} % Felix
    \end{subsection}

    \begin{subsection}*{Vraag 4} % Enver
    \end{subsection}

    \begin{subsection}*{Vraag 5} % Ruben
    	Als er een even aantal (groter dan 2) syndromen verschillend zijn van de nulvector,
    	dan zal weten wij dat de pariteitsbit juist staan, maar wij weten dan niet hoe we
    	de fouten moeten corrigeren. Dit geval staat ook niet in de ge\"iplementeerde code,
    	dus deze soorten fouten zullen niet verbeterd worden.
    	Een tweede geval waarbij er fout gecorrigeerd kan worden is wanneer er een fout
    	optreed in de laatste rij van een blok, de pariteitsbits. Wanneer op deze positie
    	ook in een bepaalde rij een van nul verschillend syndroom voorkomt dan kan het zijn
    	dat een fout op de verkeerde manier hersteld zal worden.
    \end{subsection}

    \begin{subsection}*{Vraag 6} % Jimmy
    \end{subsection}

    \begin{subsection}*{Vraag 7} % Felix
    \end{subsection}

\end{section}

\begin{section}*{Volledig systeem} % Enver
\end{section}

\end{document}
